<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>broken&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="broken&#39;s blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="broken&#39;s blog">
<meta property="og:locale">
<meta property="article:author" content="guopeixiong">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="broken's blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">broken&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-java核心类" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/05/java%E6%A0%B8%E5%BF%83%E7%B1%BB/" class="article-date">
  <time class="dt-published" datetime="2021-03-05T14:12:36.000Z" itemprop="datePublished">2021-03-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/05/java%E6%A0%B8%E5%BF%83%E7%B1%BB/">java核心类</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><ol>
<li><p><strong>String</strong>是一个<strong>引用类型</strong>,其本身就是一个class,但<strong>String</strong>不能被继承,原因是<strong>String</strong>类的的定义是<strong>final</strong>类.</p>
</li>
<li><p>字符串比较需要用<strong>equals</strong>,==比较的是引用,虽然java在编译时会将相同的字符串当做一个对象放入常量池,此时字符串的引用相同,但要比较字符串必须总是调用<strong>equals</strong>方法.</p>
</li>
<li><p><strong>String</strong>常用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">contains(String s);<span class="comment">//是否包含子字符串s</span></span><br><span class="line">indexOf(String s);<span class="comment">//返回子字符串s第一次出现的位置下标</span></span><br><span class="line">lastIndextOf(String s);<span class="comment">//返回子字符串s最后一次出现的位置下标</span></span><br><span class="line">starsWith(String s);<span class="comment">//否以字符串s开始</span></span><br><span class="line">endWith(String s);<span class="comment">//否以字符串s结束</span></span><br><span class="line">substring(<span class="keyword">int</span> s);<span class="comment">//提取从下标先开始的子字符串</span></span><br><span class="line">substring(<span class="keyword">int</span> start, <span class="keyword">int</span> end);<span class="comment">//提取从下标start开始到end-1的子字符串</span></span><br><span class="line">trim();<span class="comment">//去除首尾空格</span></span><br><span class="line">strip();<span class="comment">//去除首尾空格但类似中文的空格\u3000也会被移除</span></span><br><span class="line">isEmpty();<span class="comment">//判断字符串是否为空</span></span><br><span class="line">isBlank();<span class="comment">//判断字符串是否为空白字符串</span></span><br><span class="line">replace(<span class="keyword">char</span> a,<span class="keyword">char</span> b);<span class="comment">//将所有的字符a换成b</span></span><br><span class="line">replace(String a,String b);<span class="comment">//将所有子字符串a换成b</span></span><br><span class="line">split(String regex);<span class="comment">//以正则表达式regex为分隔符分割字符串</span></span><br><span class="line">join(String s,String[] arr);<span class="comment">//用指定的字符串连接指定的字符串数组</span></span><br><span class="line">formatted();<span class="comment">//格式化字符串</span></span><br><span class="line">format();<span class="comment">//格式化字符串</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>类型装换</strong></p>
<ul>
<li>将基本类型或引用类型转换为字符串,调用<strong>String</strong>的静态方法<strong>valueOf</strong></li>
<li>将字符串转换为其他类型,调用相应类型的类方法,如<strong>Integer.parseInt(“1234”)</strong>;</li>
<li>转换为<strong>char</strong>数组,调用方法<strong>toCharArray();</strong></li>
</ul>
</li>
</ol>
<hr>
<h2 id="StringBuilder与StringBuffer类"><a href="#StringBuilder与StringBuffer类" class="headerlink" title="StringBuilder与StringBuffer类"></a>StringBuilder与StringBuffer类</h2><p><strong>StringBuilder</strong>是一个可变对象,可预分配缓冲区,可高效拼接字符串,调用<strong>append()**方法进行拼接,**StringBuilder</strong>还可以进行链式操作,因为其<strong>append</strong>方法会返回实例本身.</p>
<p><strong>StringBuffer</strong>是<strong>StringBuilder</strong>早期的一个线程安全版本,可以保证多个线程操作<strong>StringBuffer</strong>也是安全的,但是也相应的带来效率变低</p>
<hr>
<h2 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h2><ol>
<li><p><strong>Math</strong>类主要用来进行数学计算,它提供了大量的静态方法让我们用来实现数学计算</p>
</li>
<li><p>常用方法</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">abs(-<span class="number">7</span>);<span class="comment">//求绝对值</span></span><br><span class="line">max(a,b);<span class="comment">//取最大值</span></span><br><span class="line">min(a,b);<span class="comment">//取最小值</span></span><br><span class="line">pow(a,b);<span class="comment">//计算a的b次方</span></span><br><span class="line">sqrt(a);<span class="comment">//计算根号a</span></span><br><span class="line">exp(a);<span class="comment">//计算e的a次方</span></span><br><span class="line">log(a);<span class="comment">//计算以e为底的对数</span></span><br><span class="line">log10(a);<span class="comment">//计算以10为底的对数</span></span><br><span class="line"><span class="comment">//三角函数</span></span><br><span class="line">sin(a);</span><br><span class="line">cos(a);</span><br><span class="line">tan(a);</span><br><span class="line">asin(a);</span><br><span class="line">acos(a);</span><br><span class="line"><span class="comment">//数学常量</span></span><br><span class="line">Math.PI;</span><br><span class="line">Math.E;</span><br><span class="line">Math.random();<span class="comment">//获取一个0~1的随机数</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h2 id="Random类"><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h2><ol>
<li><p><strong>Random</strong>用来创建伪随机数,伪随机数是指只要给定一个初始的种子,产生的随机数序列是完全一样的</p>
</li>
<li><p>用法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Random ran=<span class="keyword">new</span> Random();</span><br><span class="line">ran.nextInt();<span class="comment">//生成一个随机的int值</span></span><br><span class="line">ran.nextInt(<span class="number">20</span>);<span class="comment">//生成一个0~20之间的随机int值</span></span><br><span class="line">ran.nextLong();<span class="comment">//生成一个随机的long值</span></span><br><span class="line">ran.nextFloat();<span class="comment">//生成一个0~1之间的float值</span></span><br><span class="line">ran.nextDouble();<span class="comment">//生成一个0~1之间的double值</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h2 id="SecureRandom类"><a href="#SecureRandom类" class="headerlink" title="SecureRandom类"></a>SecureRandom类</h2><ol>
<li><p><strong>SecureRandom</strong>无法指定种子,<strong>SecureRandom</strong>使用RNG算法(random number generator),<strong>SecureRandom</strong>通过操作系统提供的安全的随机种子来生成随机数.因而<strong>SecureRandom</strong>生成的随机数更安全</p>
</li>
<li><p>使用例子如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.security.SecureRandom;</span><br><span class="line"><span class="keyword">import</span> java.security.NoSuchAlgorithmException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SecureRandom sr = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sr = SecureRandom.getInstanceStrong(); <span class="comment">// 获取高强度安全随机数生成器</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            sr = <span class="keyword">new</span> SecureRandom(); <span class="comment">// 获取普通的安全随机数生成器</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">16</span>];</span><br><span class="line">        sr.nextBytes(buffer); <span class="comment">// 用安全随机数填充buffer</span></span><br><span class="line">        System.out.println(Arrays.toString(buffer));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/05/java%E6%A0%B8%E5%BF%83%E7%B1%BB/" data-id="ckm3i25ef0003wkyl0y1b5t9i" data-title="java核心类" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-GUI学习笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/04/GUI%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2021-03-04T13:53:08.000Z" itemprop="datePublished">2021-03-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/04/GUI%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">GUI学习笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h3><h5 id="JFrame-：底层容器，可以向其中添加组件但是不可将JFrame添加到其他容器中"><a href="#JFrame-：底层容器，可以向其中添加组件但是不可将JFrame添加到其他容器中" class="headerlink" title="JFrame ：底层容器，可以向其中添加组件但是不可将JFrame添加到其他容器中"></a><strong>JFrame</strong> ：底层容器，可以向其中添加组件但是不可将JFrame添加到其他容器中</h5><p>JMenuBar：菜单条，菜单需要添加到菜单条中<br>JMenu：菜单，将一个菜单添加到一个菜单中这个菜单就成为子菜单<br>JMenuIten：菜单项，需要添加到菜单中<br>Icon：图标，<code>Icon icon=new ImageIcon(&quot;图片名&quot;);菜单项.setIcon(icon);</code><br>即可创建菜单图标<br><strong>常用组件</strong><br>JTextField:文本框<br>JTextArea：文本区<br>JButton：按钮<br>JLabel：标签<br>JChexBox：复选框<br>JRadioButton：单选按钮<br>JComboBox:下拉列表<br>JPasswordField：密码框<br><strong>常用容器</strong><br>JPanel:面板，通常创建面板将组件添加在面板上后将面板添加到其他容器中<br>JTabbedPane：选项卡格窗<br>JScrollPane：滚动格窗<br>JSplitPane：拆分格窗<code>JSpiitPane(int a,Component b,Component c)</code>参数HORIZONTAL_SPLIT(水平拆分)或VERTICAL_SPLIT(垂直拆分)<br>JLayeredPane：分层格窗<br><strong>常用布局</strong><br>FlowLayout：每一行的组件都居中排列，一行排满后排到下一行，按先添加的先后顺序从左到右排列<br>BorderLayouot：划分为5各区域，上北下南左西右东中，中间的区域最大，每个区域只能放一个组件，如果此区域已经放置了一个组件在次添加组件则会替换掉原来的组件<br>CardLayout：组件被层叠放入容器中，最先加入的在第一张，以此类推，与扑克牌相似一次只能抽一张出来显示，被显示的组件将占据整个容器空间<br>GridLayout：网格布局，组件添加顺序为第一行第一个，第二个，……第n行最后一个<br>null：空布局，自定义组件在容器中的位置<br>BoxLayout：<code>static  createHorizontalBox()</code> 可获得一个行型盒式容器，<code>static createHorizontalStrut(int width)</code> 可创建一个水平支撑，使水平组件之间有距离<br><code>static createVerticalBox()</code> 可获得一个列式容器<code>creaVerticalStrut(int height)</code> 可创建一个垂直支撑，使垂直组件之间有距离</p>
<h3 id="处理事件"><a href="#处理事件" class="headerlink" title="处理事件"></a>处理事件</h3><p><strong>ActionEvent事件 ** ：文本框，按钮，菜单项，密码框，单选按钮可触发ActionEvent事件<br>ActionListeren接口：<br><code>public void actionPerformed(ActionEvent e)</code> 对事件做出处理<br>ActionEvent事件对象调用<code>public Object getSource()</code> 可以获取发生此事件的事件源对象的引用<br>ActionEvent事件对象调用<code>public String getActionCommand()</code> 可以获取发生此事件时和该事件相关的一个“命令”字符串，事件源对象可事先调用<code>setCommand(String s)</code> 改变封装到事件中的默认“命令”<br>**ItemEvent事件</strong>：选择框，下拉列表，可触发ItemEvent事件<br>ItemListener接口：<br><code>public void itemStateChanged(ItemEvent e)</code> 对事件做出处理<br>ItemEvent事件对象调用<code>getSource()</code> 或<code> getItemSelectable()</code> 返回事件源对象<br><strong>DocumentEvent事件</strong>：文本区中的文本进行编辑操作使文本数据发生改变即出发DocumentEvent事件<br>DocumentListener接口：<br><code>public void changeUpdate(DocumentEvent e)</code> 用于处理文本内容被改变事件<br><code>public void removeUpdate(DocumentEvent e)</code> 用于处理文本内容被移除事件<br><code>public void insertUpdate(DocumentEvent e)</code> 用于处理插入文本内容事件 <strong>MouseEvent事件</strong>：鼠标进入组件、退出组件、在组件上单击鼠标、拖动鼠标都可以触发MouseEvent事件<br>MouseEvent类重要方法：<br><code>getX()</code> 获取鼠标指针在事件源坐标系中的X坐标<br><code>getY()</code> 获取鼠标指针在事件源坐标系中的Y坐标<br><code>getModifiers()</code> 获取鼠标的左键或右键，左右键分别用InputEvent中的常量<code>BUTTON1_MASK</code> 和<code>BUTTON3_MASK</code> 来表示<br><code>getClickCount()</code> 获取鼠标被单击的次数<br><code>getSource</code> 获取发生鼠标事件的事件源<br>MouseListener接口：<br><code>mousePressed(MouseEvent e)</code> 处理在组件上按下鼠标键触发的事件<br><code>mouseReleased(MouseEvent e)</code> 处理在组件上释放鼠标键触发的事件<br><code>mouseEntered(MouseEvent e)</code> 处理鼠标进入组件时触发的事件<br><code>mouseExited(MouseEvent e)</code> 处理鼠标退出组件时触发的事件<br><code>mouseClicked(MouseEvent e)</code> 处理鼠标在组件上单击时触发的事件<br>MouseMotionListener接口：<br><code>mouseDragged(MouseEvent e)</code> 处理拖动鼠标时（不必在事件源上）发生的事件<br><code>mouseMoved(MouseEvent e)</code> 处理在事件源上移动鼠标时发生的事件<br><strong>焦点事件</strong>:组件从无输入焦点变成有输入焦点或从有输入焦点变成无输入焦点都可以触发FocusEvent事件<br>FocusListener接口：<br><code>focusGained(FocusEvent e)</code> 处理从无输入焦点变成有输入焦点触发的焦点事件<br><code>focusLost(FocusEvent e)</code> 处理从有输入焦点变成无输入焦点触发的焦点事件<br>可以单击组件使其有输入焦点，同时使得其他组件变成无输入焦点，一个组件也可调用<code>public boolean requestFocussInWindow()</code> 获得输入焦点<br><strong>键盘事件</strong>：按下、释放或敲击键盘上的一个键时就触发了键盘事件<br>KeyEvent类重要方法：<br><code>public int getKeyCode()</code> 判断哪个键被按下、释放、敲击,返回一个键码值<br><code>public char getKeyChar()</code> 判断哪一个键被按下、释放、敲击，返回键上的字符<br>KeyLisener接口：<br><code>public void keyPressed(KeyEvent e)</code> 处理按下键盘键时触发的键盘事件<br><code>public void keyTyped(KeyEvent e)</code> 处理敲击键盘键时触发的键盘事件<br><code>public void keyReleased(KeyEvent e)</code> 处理shif键盘键时触发的键盘事件<br><strong>窗口事件</strong>：当一个窗口被激活、撤销激活、打开、关闭、图标化、撤销图标化时，就触发了窗口事件(若准备处理窗口事件就必须保证窗口的默认关闭方式为DO_NOTHING_ON_CLOSE）         WindowListener接口：<br><code>public void windowActivated(WindowEvent e)</code> 窗口从非激活到激活时调用此方法<br><code>public void windowDeactivated(WindowEvent e)</code> 窗口从激活到非激活时调用此方法<br><code>public void windowClosing(WindowEvent e)</code> 窗口正在被关闭时调用此方法<br><code>public void windowClosed(WindowEvent e)</code> 窗口关闭后调用此方法<br><code>public void windowIconified(windowEvent e)</code> 窗口图标化时调用此方法<br><code>public void windowDeiconified(WindowEvent e)</code> 窗口撤销图标化时，调用此方法<br><code>public void windowOpened(WindowEvent e)</code> 窗口打开时调用此方法<br>WindowAdapter适配器：<br>WindowAdapter类实现了WindowListener接口，可以用WindowAdapter的子类创建对象做监视器，在子类中重写所需的接口方法</p>
<hr>
<h3 id="对话框（JDialog）"><a href="#对话框（JDialog）" class="headerlink" title="对话框（JDialog）"></a><strong>对话框（JDialog）</strong></h3><p><strong>消息对话框</strong>：(javax.swing包中，消息对话框为有模式对话框）<br>JOptionPane类静态方法<code>showMessageDialog</code> 可得到一个消息对话框<br><code>public static void showMessageDialog(Component parentCompont,String message,String title,int messageType)</code> messageType取JOptionPane中的类常量：<code>INFORMATION_MESSAGE</code>    <code>WARNING_MESSAGE</code>    <code>ERROR_MESSAGE</code>    <code>QUESTION_MESSAGE</code>    <code>PLAIN_MESSAGE</code><br><strong>输入对话框</strong>：（输入对话框是有模式对话框）<br>JOptionPane类静态方法<code>showInputDialog</code> 可得到一个确认对话框<br><code>public static void showInoutDialog(Component parentComponent,Object message,String title,int messType)</code><br>messTypew为JoptionPane中的类常量：<code>INFORMATION_MESSAGE``WARNING_MESSAGE``ERROR_MESSAGE</code>    <code>QUESTION_MESSAGE</code>    <code>PLAIN_MESSAGE</code><br>单击输入对话框的确认按钮，对话框返回文本框中的字符串否则返回null<br><strong>确认对话框</strong>：（确认对话框是有模式对话框）<br>JOptionPane类静态方法<code>showConfirmDialog</code>可得到一个确认对话框<br><code>public static int showConfirmDialog(Component parentComponent,Object message,String title,int optionType)</code><br>messType可取JoptionPane中的类常量：<code>YES_NO_OPTION</code> <code>YES_NO_CANCEL_OPTION</code> <code>OK_CANCEL_OPTION</code><br>当对话框被关闭后showConfirmDialog会返回下列整数值之一：<code>JOptionPane.YES_OPTION</code> ,<code>JOptionPane.NO_OPTION</code> ,<code>JOptionPane.CANCEL_OPTION</code> ,<code> JOptionPane.OK_OPTION</code> ,<code>JOptionPane.CLOSE_OPTION </code><br><strong>颜色对话框</strong>：<br>javax.swing包中的JColorChooser类的静态方法<code>public static Color showDialog(Component component,String title,Color initialColor)</code> 创建一个有模式的颜色对话框，选择颜色后单击确认按钮<code>showDialog（）</code>返回所选择的颜色对象，否则返回空<br><strong>自定义对话框</strong>：</p>
<ul>
<li>可以通过建议JDialog的子类来建立一个对话框类，这个类的实例就是一个对话框</li>
<li>默认布局：borderLayout</li>
<li>对话框可见时，默认被添加到显示器屏幕上，不可添加到另一个容器中</li>
<li>常用构造方法：1. JDialog（）</li>
<li>   2.JDialog（JFrame owner）</li>
</ul>
<hr>
<h3 id="树组件（JTree"><a href="#树组件（JTree" class="headerlink" title="树组件（JTree)"></a>树组件（JTree)</h3><p><strong>创建</strong></p>
<ul>
<li>任何实现MutableTreeNode接口的类创建的对象都可以成为树上的结点</li>
<li>可使用javax.swing.tree包提供的DefaultMutableTreeNode类创建树上的结点<br>DefauleMutableNode类常用构造方法：<code>DefaultMutableNode(Object userObject)``DefaultMutableNode(Object userObject,boolean allowChildren)</code><br>结点调用<code>getUserObject()</code>可得到节点中存放的对象<br><code>setAllowChildren(boolean b)</code> 可设置是否允许有子结点</li>
<li>创建好结点并规定好父子关系后用JTree的构造方法<code>JTree(TreeNode root)</code>创建根节点为root的树组件<h3 id="TreeSelectionEvent事件"><a href="#TreeSelectionEvent事件" class="headerlink" title="TreeSelectionEvent事件"></a>TreeSelectionEvent事件</h3></li>
<li>鼠标单击树上的结点触发TreeSelectionEvent事件</li>
<li>TreeSelectionListener接口：</li>
<li><code>public void valueChanged(TreeSelectionEvent e)</code><br><code>getLastSelectedComponent()</code> 树调用此方法可获取选中的结点</li>
</ul>
<hr>
<h3 id="表格组件（JTable）："><a href="#表格组件（JTable）：" class="headerlink" title="表格组件（JTable）："></a><strong>表格组件（JTable）</strong>：</h3><ul>
<li>常用构造方法：<br>JTable()创建默认的表格模型<br>JTable（int a，int b）创建a行b列的默认模型表格<br>JTable（Object date[][],Object columnName[])创建默认表格模型对象，列名由columnName指定</li>
<li>在表格中编辑数据后需要按回车或用鼠标单击表格的单元格确定所编辑的结果</li>
<li>当表格需要刷新显示时让表格调用<code>repaint()</code>方法</li>
</ul>
<hr>
<h3 id="按钮绑定到键盘："><a href="#按钮绑定到键盘：" class="headerlink" title="按钮绑定到键盘："></a>按钮绑定到键盘：</h3><p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">InputMap inputmap=button.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW);</span><br><span class="line">inputmap.put(KeyStroke.getKeyStroke(<span class="string">&quot;A&quot;</span>),<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">ActionMap actionmap=button.getActionMap();</span><br><span class="line">Police listener=<span class="keyword">new</span> Police();</span><br><span class="line">actionmap.put(<span class="string">&quot;dog&quot;</span>,listener);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Police</span> <span class="keyword">extends</span> <span class="title">AbstractAction</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="打印组件"><a href="#打印组件" class="headerlink" title="打印组件"></a>打印组件</h3><p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PrintJob p=getToolkit().getPrintJob(JFrame f,String s,<span class="keyword">null</span>);</span><br><span class="line">Graphics g=p.getGraphics();<span class="comment">//p获取一个用于打印的Graphics对象</span></span><br><span class="line">g.translate(<span class="keyword">int</span> x,<span class="keyword">int</span> y);<span class="comment">//在打印页的(x，y)坐标处开始打印组件</span></span><br><span class="line">button.printAll(g);<span class="comment">//打印当前按钮</span></span><br><span class="line">g.disopose();<span class="comment">//释放对象g</span></span><br><span class="line">p.end();</span><br></pre></td></tr></table></figure>
<h3 id="发布GUI程序"><a href="#发布GUI程序" class="headerlink" title="发布GUI程序"></a>发布GUI程序</h3><p>一、用文本编辑器写一个清单文件<br>例如：<br>Mymoon.mf:<br>Manifest-Version: 1.0<br>Main-Class: A<br>Created-By: 1.6<br>二、生成JAR文件<br><code>D:\test&gt; jar cfm Tom.jar Mymoon.mf A.class B.class</code><br>test为清单文件与程序所需字节码所在的文件夹</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/04/GUI%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" data-id="ckm3i25e80000wkyl4e2q9uwl" data-title="GUI学习笔记" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-多线程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/02/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2021-02-25T08:02:56.000Z" itemprop="datePublished">2021-02-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/02/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="一-进程与线程"><a href="#一-进程与线程" class="headerlink" title="一.进程与线程"></a>一.进程与线程</h3><p>线程在进程中,一个进程可以有多个线程;一个java程序运行时至少会启动两个线程,<strong>主线程main线程</strong>与<strong>垃圾回收线程</strong>,其中<strong>main线程</strong>为<strong>前台线程</strong>或<strong>用户线程</strong>,<strong>垃圾回收线程</strong>为<strong>后台线程</strong>也称<strong>守护线程</strong>,这类线程会在<strong>前台线程</strong>结束后才结束.</p>
<hr>
<h3 id="二-线程的创建与启动"><a href="#二-线程的创建与启动" class="headerlink" title="二.线程的创建与启动"></a>二.线程的创建与启动</h3><p><strong>创建线程常用方法</strong></p>
<ol>
<li><p>继承于<strong>Thread</strong>类,重写<strong>run</strong>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendsThread</span></span>&#123;</span><br><span class="line">    <span class="comment">//重写run方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//这里面即为线程体,此线程要执行的操作</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建新线程对象</span></span><br><span class="line">    ExtendsThread newthread=<span class="keyword">new</span> ExtendsThread();</span><br><span class="line">    <span class="comment">//启动线程</span></span><br><span class="line">    newthread.start();<span class="comment">//star方法只能调用一次</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>实现<strong>Runable</strong>接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">newThread</span> <span class="keyword">implements</span> <span class="title">Runable</span></span>&#123;</span><br><span class="line">    <span class="comment">//重写接口方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//这里面即为线程体,此线程要执行的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建新线程对象</span></span><br><span class="line">        Thread newthread=<span class="keyword">new</span> Thread(<span class="keyword">new</span> newThread());</span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        newthread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用匿名内部类创建并启动线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">newthread</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runable&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>Thread</strong>类常用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">getName();<span class="comment">//返回此线程的名称</span></span><br><span class="line">currentThread();<span class="comment">//返回当前线程对象的引用,此方法为static方法</span></span><br><span class="line">getPriority();<span class="comment">//返回此线程的优先级</span></span><br><span class="line">getState();<span class="comment">//返回此线程的状态</span></span><br><span class="line">interrupt();<span class="comment">//中断这个线程</span></span><br><span class="line">isInterrupted();<span class="comment">//测试这个线程是否被中断	</span></span><br><span class="line">isAlive();<span class="comment">//测试这个线程是否活着,启动至死亡期间都返回true	</span></span><br><span class="line">isDaemon();<span class="comment">//测试这个线程是否是守护线程</span></span><br><span class="line">join();<span class="comment">//独占CPU资源直到此线程死亡	</span></span><br><span class="line">setDaemon(<span class="keyword">boolean</span> on);<span class="comment">//将此线程修改为守护线程,但需在启动前修改	</span></span><br><span class="line">setName(String name);<span class="comment">//将此线程的名字修改为参数name </span></span><br><span class="line">setPriority(<span class="keyword">int</span> newPriority);<span class="comment">//更改此线程的优先级</span></span><br><span class="line">sleep(<span class="keyword">long</span> millis);<span class="comment">//使当前线程睡眠参数指定的毫秒数,此方法为static方法</span></span><br><span class="line">start();<span class="comment">//启动线程</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h3 id="三-线程状态"><a href="#三-线程状态" class="headerlink" title="三.线程状态"></a>三.线程状态</h3><ol>
<li><p>根据<strong>API</strong>里的<strong>Thread.State</strong>,线程状态一共有6种,分别是*<strong>NEW**<em>,</em></strong>RANBLE*<strong>,**<em>BLOCKED</em></strong>,<strong><em>WAITING</em></strong>,<strong><em>TIMED_WAITING</em></strong>,<strong><em>TERMINATED</em></strong></p>
</li>
<li><ul>
<li><p><strong><em>NEW</em></strong><br>当创建建一个新的线程对象但未调用<strong>star</strong>方法时，此时该线程状态为新建状态</p>
</li>
<li><p><strong><em>RUNABLE</em></strong><br>当一线程对象调用start方法,此时该线程即可被JVM调度进行运行,若此时线程在等待JVM调度则为就绪状态(ready),若获得CPU资源在运行则为运行状态(running)</p>
</li>
<li><p><strong><em>BLOCKED</em></strong><br>此状态为阻塞状态,当一个线程因为某种原因放弃CPU资源停止运行此时就进入了阻塞状态,阻塞状态只能先进入就绪状态,不能直接进入运行状态.(当线程对象获取同步锁却被其他线程对象获取时或运行过程中发出IO请求线程进入阻塞状态)</p>
</li>
<li><p><strong><em>WAITING</em></strong></p>
<p>当线程调用了无参的<strong>wait</strong>方法或<strong>join</strong>方法且,此时线程进入等待状态</p>
</li>
<li><p><strong><em>TIMED_WAITING</em></strong></p>
<p>当线程调用了<strong>sleep</strong>方法或调用了有参的<strong>wait</strong>与<strong>join</strong>方法,此时线程进入计时等待状态</p>
</li>
<li><p><strong><em>TERMINATED</em></strong></p>
<p>线程执行完<strong>run</strong>方法后退出或执行过程中遇到异常而退出此时线程为终止状态</p>
</li>
</ul>
</li>
</ol>
<hr>
<h3 id="四-线程调度与线程优先级"><a href="#四-线程调度与线程优先级" class="headerlink" title="四.线程调度与线程优先级"></a>四.线程调度与线程优先级</h3><ol>
<li>处于就绪状态的线程进入就绪排队队列等待CPU资源,JVM的线程调度器负责管理线程,线程的优先级为1~10,即在<strong>Thread.MIN_PRIORITY</strong>与<strong>Thread.MAX_PRIORITY</strong>之间,若没有明确设置线程优先级,默认优先级为<strong>Thread.NORM_PRIORITY</strong>即为5.优先级高的线程获得的机会比低优先级的线程多</li>
<li><strong>Thread</strong>类中提供了修改线程优先级的方法<strong>setPriority(int newPriority)</strong>;以及可以返回此线程优先级的方法<strong>getPriority()</strong></li>
</ol>
<hr>
<h3 id="五-线程同步"><a href="#五-线程同步" class="headerlink" title="五.线程同步"></a>五.线程同步</h3><p><strong>多线程抢夺CPU资源时容易出现程序运行错乱,同步线程可使个程序运行更加有序</strong></p>
<ol>
<li><p>同步代码代码块</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*同步代码块即将要同步执行的代码放在synchronized中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">synchronized</span>(Object e)&#123;<span class="comment">//e为同步资源的对象即同步锁获取对象,</span></span><br><span class="line">	<span class="comment">//这里面即可放置需要同步执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>同步方法</p>
<p>在方法前加上一个<strong>synchronized</strong>修饰符,但不要加在<strong>run</strong>方法前,可以另写一个方法后在<strong>run</strong>方法中调用</p>
</li>
</ol>
<p><strong><em>注意</em></strong> <strong>: synchronized</strong>会影响性能,应尽可能减小<strong>synchronized</strong>的作用域</p>
<ol start="3">
<li><p>使用锁机制(<strong>Lock</strong>接口)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先创建锁对象,可以使用实现Lock接口的类,这里示例使用ReentrantLock</span></span><br><span class="line">Lock lock=<span class="keyword">new</span> ReetrantLock();</span><br><span class="line"><span class="comment">//推荐在run方法中使用try-catch-finally块,进入run后马上获取锁,在finally中释放锁</span></span><br><span class="line">lock.lock();<span class="comment">//获取锁</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>()&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">    lock.unlock();<span class="comment">//释放锁</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h3 id="六-线程通信"><a href="#六-线程通信" class="headerlink" title="六.线程通信"></a>六.线程通信</h3><ol>
<li><p>使用<strong>synchronized</strong>则使用<strong>Object</strong>中的<strong>wait</strong>(),<strong>notify</strong>(),<strong>notifyAll</strong>()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这些方法只能由同步锁持有对象调用,因而使用锁机制Lock不能使用这些方法</span></span><br><span class="line">wait();<span class="comment">//无参的wait使当前线程可进入等待状态</span></span><br><span class="line">wait(<span class="keyword">long</span> m);<span class="comment">//有参的wait使当前线程最多等待参数指定的毫秒数,若没被唤醒则自动唤醒</span></span><br><span class="line">notify();<span class="comment">//唤醒任意一个等待线程</span></span><br><span class="line">notifyAll();<span class="comment">//唤醒所有等待线程</span></span><br><span class="line"><span class="comment">//以上方法不可在非同步方法中使用</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用锁机制<strong>Lock</strong>的则使用<strong>Condition</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Condition实质上是被绑定到一个锁上,可以是使用newCondition()为特定的锁绑定Condition</span></span><br><span class="line">Lock lock=<span class="keyword">new</span> ReetrantLock(); </span><br><span class="line">Condition contidion=lock.newCondition();</span><br><span class="line"><span class="comment">//Condition对象可调用下列方法</span></span><br><span class="line">await();<span class="comment">//使当前线程进入等待状态</span></span><br><span class="line">signal();<span class="comment">//唤醒任意一个等待线程</span></span><br><span class="line">signalAll();<span class="comment">//唤醒所有等待线程</span></span><br></pre></td></tr></table></figure>


</li>
</ol>
<h3 id="七-线程联合"><a href="#七-线程联合" class="headerlink" title="七.线程联合"></a>七.线程联合</h3><p>一个线程A在占有CPU资源期间,可以线程B调用**join()**方法和A线程联合,此时A线程会立即中断,一直等到B线程死亡,再重新排队等候CPU资源,若B线程在联合前已死亡则此操作不产生任何效果</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" data-id="ckm3i25el0009wkyl7kafepbk" data-title="多线程" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Java输入输出流" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/02/19/Java%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/" class="article-date">
  <time class="dt-published" datetime="2021-02-19T02:39:29.000Z" itemprop="datePublished">2021-02-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/02/19/Java%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/">Java输入输出流</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="文件类File"><a href="#文件类File" class="headerlink" title="文件类File"></a>文件类File</h2><ol>
<li><p>构造方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File(String filename);<span class="comment">//filename 文件名字，此构造方法默认与当前应用程序在同一目录中</span></span><br><span class="line">File(String directoryPath,String filename);<span class="comment">//directoyPath 文件路径</span></span><br><span class="line">File(File dir,String filename);<span class="comment">//dir 目录</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>常用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>;<span class="comment">//获取文件名字</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canRead</span><span class="params">()</span></span>;<span class="comment">//判断文件是否可读</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canWrite</span><span class="params">()</span></span>;<span class="comment">//判断文件是否可被写入</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exists</span><span class="params">()</span></span>;<span class="comment">//判断文件是否存在</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">length</span><span class="params">()</span></span>;<span class="comment">//获取文件的长度（字节）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getAbsolutePath</span><span class="params">()</span></span>;<span class="comment">//获取文件的绝对路径</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getParent</span><span class="params">()</span></span>;<span class="comment">//获取文件的父目录</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFile</span><span class="params">()</span></span>;<span class="comment">//判断文件是否一个普通文件而不是目录</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDirectory</span><span class="params">()</span></span>;<span class="comment">//判断文件是否是一个目录</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHiden</span><span class="params">()</span></span>;<span class="comment">//判断文件是否是隐藏文件</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">lastModified</span><span class="params">()</span></span>;<span class="comment">//获取文件最后修改的时间</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>目录：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">mkdir</span><span class="params">()</span></span>;<span class="comment">//创建一个目录成功返回true，失败false，该目录已存在返回false</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">mkdirs</span><span class="params">()</span></span>;<span class="comment">//创建一个文件夹和它所有的父文件夹</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//若一个File对象是一目录，可调用下列方法</span></span><br><span class="line"><span class="keyword">public</span> String[] list();<span class="comment">//以字符串的形式返回目录下的所有文件</span></span><br><span class="line"><span class="keyword">public</span> File[] listFile();<span class="comment">//以File对象形式返回目录下的全部文件 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回指定后缀名文件</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">    File dieFile=<span class="keyword">new</span> (<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    FileAccept fileAccept=<span class="keyword">new</span> fileAccept();</span><br><span class="line">    fileAccept.setExtendName(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">    String fileName[]=dirFile.list(fileAccept);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FieldAccept</span> <span class="keyword">implements</span> <span class="title">FilenameFiler</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String extendName;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setExtendName</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        extendName=<span class="string">&quot;.&quot;</span>+s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir,String name)</span></span>&#123;<span class="comment">//重写接口方法</span></span><br><span class="line">        <span class="keyword">return</span> name.endsWith(extendName);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>文件创建与删除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当文件对象创建对象后该目录下没有该文件文件对象可调用以下方法创建一个</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">createNewFile</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//调用以下的方法可以删除文件</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>运行可执行文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先要使用java.lang包中的Runtime类声明一个对象，然后使用该类的静态方法创建这个对象</span></span><br><span class="line">Runtime ec;</span><br><span class="line">ec=Runtime.getRuntime();</span><br><span class="line"><span class="comment">//接着调用下列的方法打开本地机器上的可执行文件或执行一个操作</span></span><br><span class="line">ec.exec(String command);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h2 id="文件字节输入流（FileInputStream）"><a href="#文件字节输入流（FileInputStream）" class="headerlink" title="文件字节输入流（FileInputStream）"></a>文件字节输入流（FileInputStream）</h2><ol>
<li><p>构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//程序必须在try里创建输入输出流，在catch中捕获异常并处理异常</span></span><br><span class="line"><span class="comment">//创建源是指定文件或File对象的输入流</span></span><br><span class="line">FileInputStream(String name);</span><br><span class="line">FileInputStream(File file);</span><br></pre></td></tr></table></figure>
</li>
<li><p>读取字节</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用read方法以字节为单位读取源中的数据</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>;<span class="comment">//读取单个字节数据，返回字节值（0~255），未读出返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[])</span></span>;<span class="comment">//读取b.length个字节的数据到数组b中，返回实际读取的字节数，到达文件末尾返回</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;<span class="comment">//使用close关闭流</span></span><br></pre></td></tr></table></figure>
<h2 id="文件字节输出流（FileOutputStream）"><a href="#文件字节输出流（FileOutputStream）" class="headerlink" title="文件字节输出流（FileOutputStream）"></a>文件字节输出流（FileOutputStream）</h2></li>
<li><p>构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream(String name);</span><br><span class="line">FileOutputStream(File file);</span><br><span class="line"><span class="comment">//若指向的文件不存在Java会创建该文件，若指向的文件已存在将刷新该文件（使长度为0）</span></span><br><span class="line">FileOutputStream(String name,<span class="keyword">boolean</span> append);</span><br><span class="line">FileOutputStream(File file,<span class="keyword">boolean</span> append);</span><br><span class="line"><span class="comment">//append取true则不会刷新文件而是在文件末尾开始写入数据</span></span><br></pre></td></tr></table></figure></li>
<li><p>写字节</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用write方法以字节为单位向文件中顺序的写入内容</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> n)</span></span>;<span class="comment">//写入单个字节</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span> b[])</span></span>;<span class="comment">//写入一个字节数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span> b[],<span class="keyword">int</span> off,<span class="keyword">int</span> len)</span></span>;<span class="comment">//从位置off开始写入len长度的内容</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;<span class="comment">//关闭流，关闭后缓冲区的内容全部被冲洗至目的地</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h2 id="文件字符输入-输出流（FileReader-FileWrite，是Reader-Write的子类）"><a href="#文件字符输入-输出流（FileReader-FileWrite，是Reader-Write的子类）" class="headerlink" title="文件字符输入/输出流（FileReader/FileWrite，是Reader/Write的子类）"></a>文件字符输入/输出流（FileReader/FileWrite，是Reader/Write的子类）</h2><ol>
<li><p>构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FileReader(String filename);</span><br><span class="line">FileReader(File filename);</span><br><span class="line">FileWrite(String filename);</span><br><span class="line">FileWrite(File filename);</span><br><span class="line">FileWrite(String filename,<span class="keyword">boolean</span> append);</span><br><span class="line">FileWrite(File filename,<span class="keyword">boolean</span> append);<span class="comment">//append为true在末尾写入，否则刷新文件</span></span><br></pre></td></tr></table></figure></li>
<li><p>调用read（char c[]）write(char c[])读取和写入</p>
</li>
<li><p>对于Write流，首先将数据写入缓冲区，缓冲区溢出后再被自动写入目的地，若关闭流缓冲区的内容立刻被全部写入目的地，流调用flush（）方法可将当前缓冲区冲洗干净</p>
</li>
</ol>
<hr>
<h2 id="缓冲流（BufferedReader-BufferedWrite）"><a href="#缓冲流（BufferedReader-BufferedWrite）" class="headerlink" title="缓冲流（BufferedReader/BufferedWrite）"></a>缓冲流（BufferedReader/BufferedWrite）</h2><ol>
<li><p>构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader(Reader in);</span><br><span class="line">BuffeeredWrite(Write out);</span><br><span class="line">eg:</span><br><span class="line">FileReader inone=<span class="keyword">new</span> FileReader(<span class="string">&quot;Student.txt&quot;</span>);</span><br><span class="line">BufferedRead intwo=BufferedRead(inone);</span><br></pre></td></tr></table></figure></li>
<li><p>读取方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">read();<span class="comment">//读取一个字节</span></span><br><span class="line">read(<span class="keyword">char</span>[] cbuf, <span class="keyword">int</span> off, <span class="keyword">int</span> len);<span class="comment">//将字符读入数组的一部分</span></span><br><span class="line">readLine();<span class="comment">//读取整行</span></span><br><span class="line">write();<span class="comment">//写一个字符</span></span><br><span class="line">write(<span class="keyword">char</span>[] cbuf, <span class="keyword">int</span> off, <span class="keyword">int</span> len);<span class="comment">//写入字符数组的一部分</span></span><br><span class="line">write(String s,<span class="keyword">int</span> off,<span class="keyword">int</span> len);<span class="comment">//off为写入的字符串的起始位置，len为写入的字符个数</span></span><br><span class="line">nextLine();<span class="comment">//写入一个回行符</span></span><br></pre></td></tr></table></figure></li>
<li><p>BufferedRead，BufferedWrite称为上层流，其指向的字符流称为底层流二者之间通过缓存联系，读取和写入都先经过缓存，BufferedWrite调用flush（）刷新或close（）关闭流时底层流会立刻将缓存中的内容写进目的地，关闭流时先关闭上层流</p>
</li>
</ol>
<hr>
<h2 id="随机流（RandomAccessFile）"><a href="#随机流（RandomAccessFile）" class="headerlink" title="随机流（RandomAccessFile）"></a>随机流（RandomAccessFile）</h2><ol>
<li><p>随机流即可读也可写</p>
</li>
<li><p>构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile(String filename,String mode);<span class="comment">//随机流指向文件时，不刷新文件</span></span><br><span class="line">RandomAccessFile(File file,String mode);<span class="comment">//mode取“r”（只读）或“rw”（可读写），即创建的流对文件的访问权利</span></span><br></pre></td></tr></table></figure></li>
<li><p>常用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">getFilePointer();<span class="comment">//获取当前读写的位置</span></span><br><span class="line">length();<span class="comment">//获取文件的长度</span></span><br><span class="line">read();<span class="comment">//读取一个字节的数据</span></span><br><span class="line">readBoolean();<span class="comment">//读取一个布尔值，false为0，其他值代表true</span></span><br><span class="line">readByte();<span class="comment">//读取一个字节</span></span><br><span class="line">readChar();<span class="comment">//从文件中读取一个字符(2个字节)</span></span><br><span class="line">readDouble();<span class="comment">//从文件中读取一个双精度浮点值</span></span><br><span class="line">readFloat();<span class="comment">//从文件中读取一个单精度浮点值</span></span><br><span class="line">readFully(<span class="keyword">byte</span> b[]);<span class="comment">//读取b.length字节放入数组b</span></span><br><span class="line">readInt();<span class="comment">//从文件中读取一个int值</span></span><br><span class="line">readLine();<span class="comment">//从文件中读取一个文本行</span></span><br><span class="line">readLong();<span class="comment">//从文件中读取一个long型值</span></span><br><span class="line">readShort();<span class="comment">//从文件中读取一个short型值</span></span><br><span class="line">readUnsignedByte();<span class="comment">//读取一个无符号字节</span></span><br><span class="line">readUnsignedShort();<span class="comment">//读取一个无符号short型值</span></span><br><span class="line">readUTF();<span class="comment">//从文件中读取一个UTF字符串</span></span><br><span class="line">seek(<span class="keyword">long</span> position);<span class="comment">//定位读写位置</span></span><br><span class="line">setLength(<span class="keyword">long</span> newlength);<span class="comment">//设置文件长度</span></span><br><span class="line">shipByte(<span class="keyword">int</span> n);<span class="comment">//在文件中跳过指定数量的字节</span></span><br><span class="line">write(<span class="keyword">byte</span> b[]);<span class="comment">//写b.length个字节到文件</span></span><br><span class="line">writeBoolean(<span class="keyword">boolean</span> v);<span class="comment">//把一个布尔值作为单字节值写入文件</span></span><br><span class="line">writeByte(<span class="keyword">int</span> n);<span class="comment">//向文件中写入一个字节</span></span><br><span class="line">writeBytes(String s);<span class="comment">//向文件中写入一个字符串</span></span><br><span class="line">writeChar(<span class="keyword">char</span> c);<span class="comment">//向文件写入一个字符</span></span><br><span class="line">writeChars(String s);<span class="comment">//向文件写入一个作为字符数据的字符串</span></span><br><span class="line">writeDouble(<span class="keyword">double</span> v);<span class="comment">//向文件写入一个双精度浮点值</span></span><br><span class="line">writeFloat(<span class="keyword">float</span> v);<span class="comment">// 向文件写入一个单精度浮点数</span></span><br><span class="line">writeInt(<span class="keyword">int</span> v);<span class="comment">//向文件写入一个int值</span></span><br><span class="line">writeLong(<span class="keyword">long</span> v);<span class="comment">//向文件写入一个长型int值</span></span><br><span class="line">writeShort(<span class="keyword">int</span> v);<span class="comment">//向文件写入一个短型int值</span></span><br><span class="line">writeUTF(String s);<span class="comment">//向文件写入一个UTF字符串</span></span><br></pre></td></tr></table></figure></li>
<li><p>readLine（）方法读取含有非ASCII编码字符的文件时会出现乱码现象，需要把读取的字符串用“iso-8859-1”编码重新编码存放到byte数组中,然后再用当前机器的默认编码将该数组转换为字符串<code>String str=in.readLine(); byte b[]=str.getBytes(&quot;iso-8859-1&quot;); String s=new String(b);</code> </p>
</li>
</ol>
<hr>
<h2 id="数组流"><a href="#数组流" class="headerlink" title="数组流"></a>数组流</h2><h3 id="字节数组流（ByteArrayInputStream-ByteArrayOutputStream）"><a href="#字节数组流（ByteArrayInputStream-ByteArrayOutputStream）" class="headerlink" title="字节数组流（ByteArrayInputStream/ByteArrayOutputStream）"></a>字节数组流（ByteArrayInputStream/ByteArrayOutputStream）</h3><ul>
<li><strong>字节数组输入流</strong></li>
</ul>
<ol>
<li><p>构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteArrayInputStream(<span class="keyword">byte</span>[] buf);</span><br><span class="line">  ByteArrayInputStream(<span class="keyword">byte</span>[],<span class="keyword">int</span> offset,<span class="keyword">int</span> length);</span><br></pre></td></tr></table></figure></li>
<li><p>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">available();<span class="comment">//返回可从此流读取或返回的字节数</span></span><br><span class="line">mark(<span class="keyword">int</span> readAheadLimit);<span class="comment">//设置流中当前标记的位置</span></span><br><span class="line">markSupported();<span class="comment">//测试 InputStream是否支持标记/复位</span></span><br><span class="line">read();<span class="comment">//从该输入流读取下一个数据字节,返回读出的字节值</span></span><br><span class="line">read(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len);<span class="comment">//将 len字节的数据读入此输入流中的字节数组</span></span><br><span class="line">reset();<span class="comment">//将缓冲区重置为标记位置</span></span><br><span class="line">skip(<span class="keyword">long</span> n);<span class="comment">//从此输入流跳过 n个字节的输入</span></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><strong>字节数组输出流</strong></li>
</ul>
<ol>
<li><p>构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteArrayOutputStream();<span class="comment">//默认初始32字节</span></span><br><span class="line">ByteArrayOutputStream(<span class="keyword">int</span> size);<span class="comment">//自定义初始小</span></span><br></pre></td></tr></table></figure></li>
<li><p>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">reset();<span class="comment">//将此字节数组输出流的 count字段重置为零，以便丢弃输出流中当前累积的所有输出</span></span><br><span class="line">size();<span class="comment">//返回缓冲区的当前大小</span></span><br><span class="line">toByteArray();<span class="comment">//创建一个新分配的字节数组</span></span><br><span class="line">toString();<span class="comment">//使用平台的默认字符集将缓冲区内容转换为字符串解码字节</span></span><br><span class="line">toString(String charsetName);<span class="comment">//通过使用命名的charset解码字节，将缓冲区的内容转换为字符串</span></span><br><span class="line">write(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len);<span class="comment">//从指定的字节数组写入 len字节，从偏移量为 off开始，输出到这个字节数组输出流</span></span><br><span class="line">write(<span class="keyword">int</span> b);<span class="comment">//将指定的字节写入此字节数组输出流</span></span><br><span class="line">writeTo(OutputStream out);<span class="comment">//将此字节数组输出流的完整内容写入指定的输出流参数，就像使用 out.write(buf, 0, count)调用输出流的写入方法 out.write(buf, 0, count)</span></span><br></pre></td></tr></table></figure>
<h3 id="字符数组流（CharArrayReader-CharArrayWriter）"><a href="#字符数组流（CharArrayReader-CharArrayWriter）" class="headerlink" title="字符数组流（CharArrayReader/CharArrayWriter）"></a>字符数组流（CharArrayReader/CharArrayWriter）</h3></li>
</ol>
<ul>
<li><p>字符数组输入流</p>
<ol>
<li><p>构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CharArrayReader(<span class="keyword">char</span>[] buf);</span><br><span class="line">CharArrayReader(<span class="keyword">char</span>[] buf,<span class="keyword">int</span> offset,<span class="keyword">int</span> length)</span><br></pre></td></tr></table></figure></li>
<li><p>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mark(<span class="keyword">int</span> readAheadLimit);<span class="comment">//标记流中的当前位置</span></span><br><span class="line">markSupported();<span class="comment">//告诉这个流是否支持mark（）操作</span></span><br><span class="line">read();<span class="comment">//读一个字符</span></span><br><span class="line">read(<span class="keyword">char</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len);<span class="comment">//将字符读入数组的一部分</span></span><br><span class="line">ready();<span class="comment">//告诉这个流是否准备好被读取</span></span><br><span class="line">reset();<span class="comment">//将流重新设置为最近的标记，或将其重新设置为从未被标记的开始</span></span><br><span class="line">skip(<span class="keyword">long</span> n);<span class="comment">//跳过字符</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<hr>
<h2 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h2><h3 id="数据输入流-DateInputStream"><a href="#数据输入流-DateInputStream" class="headerlink" title="数据输入流(DateInputStream)"></a>数据输入流(DateInputStream)</h3><p> 1.构造方法：<code>DateInputStream(InputStream in);</code> </p>
<p> 2.方法</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">read(<span class="keyword">byte</span>[] b)；<span class="comment">//从包含的输入流中读取一些字节数，并将它们存储到缓冲区数组 b </span></span><br><span class="line">read(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)；<span class="comment">//从包含的输入流读取最多 len个字节的数据为字节数组</span></span><br><span class="line">readBoolean();</span><br><span class="line">readByte();</span><br><span class="line">readChar();</span><br><span class="line">readDouble();</span><br><span class="line">readFloat();</span><br><span class="line">readInt();</span><br><span class="line">readLong();</span><br><span class="line">readShort();</span><br><span class="line">readUnsignedByte();</span><br><span class="line">readUnsignedShort();</span><br><span class="line">readUTF();</span><br><span class="line">skipBytes();	</span><br></pre></td></tr></table></figure>
<h3 id="数据输出流（DateOutputStream）"><a href="#数据输出流（DateOutputStream）" class="headerlink" title="数据输出流（DateOutputStream）"></a>数据输出流（DateOutputStream）</h3><p> 1.构造方法：<code>DateOutputStream</code></p>
<p> 2.方法</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">flush();<span class="comment">//刷新此数据输出流</span></span><br><span class="line">size();<span class="comment">//返回计数器的当前值 written ，到目前为止写入此数据输出流的字节数</span></span><br><span class="line">write(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len);<span class="comment">//写入 len个从指定的字节数组起始于偏移 off基础输出流</span></span><br><span class="line">write(<span class="keyword">int</span> b);<span class="comment">//将指定的字节写入底层输出流</span></span><br><span class="line">writeBoolean(<span class="keyword">boolean</span> v);<span class="comment">//将 boolean写入底层输出流作为1字节值</span></span><br><span class="line">writeByte(<span class="keyword">int</span> v);<span class="comment">//将 byte作为1字节值写入底层输出流</span></span><br><span class="line">writeBytes(String s);<span class="comment">//将字符串作为字节序列写入基础输出流</span></span><br><span class="line">writeChar(<span class="keyword">int</span> v)；<span class="comment">//将 char写入底层输出流作为2字节值，高字节优先</span></span><br><span class="line">writeChars(String s);<span class="comment">//将字符串写入底层输出流作为一系列字符</span></span><br><span class="line">writeDouble(<span class="keyword">double</span> v);<span class="comment">//写入一个双精度浮点值</span></span><br><span class="line">writeFloat(<span class="keyword">float</span> v);<span class="comment">//写入一个单精度浮点值</span></span><br><span class="line">writeInt(<span class="keyword">int</span> v);<span class="comment">//写入一个int值</span></span><br><span class="line">writeLong(<span class="keyword">long</span> v);<span class="comment">//写入一个long型值</span></span><br><span class="line">writeShort(<span class="keyword">short</span> v);<span class="comment">//写入一个short值</span></span><br><span class="line">writeUTF(String s);<span class="comment">//写入一个UTF字符串</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="对象流（ObjectInputStream-ObjectOutputStream）"><a href="#对象流（ObjectInputStream-ObjectOutputStream）" class="headerlink" title="对象流（ObjectInputStream/ObjectOutputStream）"></a>对象流（ObjectInputStream/ObjectOutputStream）</h2><ol>
<li><p>构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ObjectInputStream(InputStream in);</span><br><span class="line">ObjectOutputStream(OutputStream out);</span><br></pre></td></tr></table></figure></li>
<li><p>常用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">writeObject(Object obj);<span class="comment">//将一个对象写入文件</span></span><br><span class="line">readObject();<span class="comment">//读入一个对象到程序中</span></span><br></pre></td></tr></table></figure></li>
<li><ul>
<li>一个对象以流的形式进行传输叫做序列化</li>
<li>对象序列化的前提是该对象的类实现Serializable接口</li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/19/Java%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/" data-id="ckm3i25ec0001wkyl85v2ct9a" data-title="Java输入输出流" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Java/" style="font-size: 10px;">Java</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/03/05/java%E6%A0%B8%E5%BF%83%E7%B1%BB/">java核心类</a>
          </li>
        
          <li>
            <a href="/2021/03/04/GUI%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">GUI学习笔记</a>
          </li>
        
          <li>
            <a href="/2021/02/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a>
          </li>
        
          <li>
            <a href="/2021/02/19/Java%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/">Java输入输出流</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 guopeixiong<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>